/**
 * Solana BPF zkVM - Browser Interface
 * 
 * Loads the WASM module and provides UI for proof generation from real traces.
 */

// Import the WASM module (generated by wasm-pack)
import init, { 
    prove_trace,
    verify_trace_proof,
    get_trace_info,
    get_prover_info 
} from './pkg/wasm_prover.js';

// State
let wasmReady = false;
let currentTraceBytes = null;
let currentProof = null;

// DOM Elements
const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');
const fileName = document.getElementById('fileName');
const traceInfo = document.getElementById('traceInfo');
const traceSteps = document.getElementById('traceSteps');
const traceInstructions = document.getElementById('traceInstructions');
const traceSyscalls = document.getElementById('traceSyscalls');
const traceSyscallWhitelist = document.getElementById('traceSyscallWhitelist');
const traceInitialR0 = document.getElementById('traceInitialR0');
const traceFinalR0 = document.getElementById('traceFinalR0');
const traceValidation = document.getElementById('traceValidation');
const proveBtn = document.getElementById('proveBtn');
const verifyBtn = document.getElementById('verifyBtn');
const statusDiv = document.getElementById('status');
const statusText = document.getElementById('statusText');
const resultsDiv = document.getElementById('results');
const proofSizeSpan = document.getElementById('proofSize');
const provingTimeSpan = document.getElementById('provingTime');
const instructionCountSpan = document.getElementById('instructionCount');
const verificationStatusSpan = document.getElementById('verificationStatus');
const proofHexTextarea = document.getElementById('proofHex');
const copyBtn = document.getElementById('copyBtn');
const step1 = document.getElementById('step1');
const step2 = document.getElementById('step2');
const step3 = document.getElementById('step3');

/**
 * Update workflow step indicators
 */
function updateSteps(current) {
    step1.className = 'workflow-step' + (current >= 1 ? (current > 1 ? ' complete' : ' active') : '');
    step2.className = 'workflow-step' + (current >= 2 ? (current > 2 ? ' complete' : ' active') : '');
    step3.className = 'workflow-step' + (current >= 3 ? ' complete' : (current === 3 ? ' active' : ''));
}

/**
 * Show status message
 */
function showStatus(message, type = 'loading') {
    statusDiv.style.display = 'flex';
    statusDiv.className = `status ${type}`;
    statusText.textContent = message;
    
    const spinner = statusDiv.querySelector('.spinner');
    if (spinner) {
        spinner.style.display = type === 'loading' ? 'block' : 'none';
    }
}

/**
 * Hide status
 */
function hideStatus() {
    statusDiv.style.display = 'none';
}

/**
 * Convert Uint8Array to hex string
 */
function toHex(bytes) {
    return Array.from(bytes)
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');
}

/**
 * Format bytes as human-readable size
 */
function formatBytes(bytes) {
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(2)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
}

/**
 * Initialize WASM module
 */
async function initWasm() {
    showStatus('Loading WASM module...', 'loading');
    
    try {
        await init();
        wasmReady = true;
        
        const info = JSON.parse(get_prover_info());
        console.log('zkVM Prover initialized:', info);
        
        showStatus('WASM module ready', 'success');
        setTimeout(hideStatus, 2000);
        
    } catch (error) {
        console.error('Failed to initialize WASM:', error);
        showStatus(`Failed to load WASM: ${error.message}`, 'error');
    }
}

/**
 * Handle file selection
 */
async function handleFile(file) {
    if (!file || !file.name.endsWith('.trace')) {
        showStatus('Please select a .trace file', 'error');
        return;
    }
    
    try {
        const arrayBuffer = await file.arrayBuffer();
        currentTraceBytes = new Uint8Array(arrayBuffer);
        
        fileName.textContent = `${file.name} (${formatBytes(file.size)})`;
        dropZone.classList.add('has-file');
        
        // Get trace info
        const info = JSON.parse(get_trace_info(currentTraceBytes));
        traceSteps.textContent = info.step_count;
        traceInstructions.textContent = info.instruction_count;
        traceSyscalls.textContent = `${info.syscalls.total} (${info.syscalls.whitelisted} whitelisted, ${info.syscalls.unknown} unknown)`;
        
        // Syscall whitelist status
        if (info.syscalls.all_whitelisted) {
            traceSyscallWhitelist.textContent = '✓ All whitelisted';
            traceSyscallWhitelist.style.color = 'var(--success)';
        } else {
            traceSyscallWhitelist.textContent = `✗ ${info.syscalls.unknown} unknown`;
            traceSyscallWhitelist.style.color = 'var(--error)';
        }
        
        traceInitialR0.textContent = info.initial_r0;
        traceFinalR0.textContent = info.final_r0;
        
        if (info.validation === 'valid') {
            traceValidation.textContent = '✓ Valid';
            traceValidation.style.color = 'var(--success)';
        } else {
            traceValidation.textContent = '✗ Invalid';
            traceValidation.style.color = 'var(--error)';
            if (info.validation_error) {
                console.error('Validation error:', info.validation_error);
            }
        }
        
        traceInfo.classList.add('visible');
        
        proveBtn.disabled = info.validation !== 'valid';
        verifyBtn.disabled = true;
        currentProof = null;
        resultsDiv.classList.remove('visible');
        
        updateSteps(1);
        showStatus('Trace loaded successfully', 'success');
        setTimeout(hideStatus, 2000);
        
    } catch (error) {
        console.error('Failed to load trace:', error);
        showStatus(`Failed to load trace: ${error.message}`, 'error');
    }
}

/**
 * Generate proof from trace
 */
async function generateProof() {
    if (!wasmReady || !currentTraceBytes) {
        showStatus('No trace loaded', 'error');
        return;
    }
    
    proveBtn.disabled = true;
    verifyBtn.disabled = true;
    resultsDiv.classList.remove('visible');
    updateSteps(2);
    
    showStatus('Generating zero-knowledge proof...', 'loading');
    
    try {
        const startTime = performance.now();
        
        // Generate proof from trace (trace stays in WASM memory)
        const proof = await prove_trace(currentTraceBytes);
        
        const endTime = performance.now();
        const provingTime = ((endTime - startTime) / 1000).toFixed(2);
        
        currentProof = proof;
        
        // Get trace info for display
        const info = JSON.parse(get_trace_info(currentTraceBytes));
        
        // Update results
        proofSizeSpan.textContent = formatBytes(proof.length);
        provingTimeSpan.textContent = `${provingTime}s`;
        instructionCountSpan.textContent = `${info.step_count} (${info.instruction_count} insns, ${info.syscall_count} syscalls)`;
        verificationStatusSpan.textContent = 'Pending';
        verificationStatusSpan.style.color = 'var(--warning)';
        proofHexTextarea.value = toHex(proof);
        
        resultsDiv.classList.add('visible');
        verifyBtn.disabled = false;
        
        showStatus('Proof generated successfully!', 'success');
        setTimeout(hideStatus, 3000);
        
        console.log('Proof generated:', {
            size: proof.length,
            time: provingTime,
            instructions: info.instruction_count
        });
        
    } catch (error) {
        console.error('Proof generation failed:', error);
        showStatus(`Proof generation failed: ${error.message}`, 'error');
    } finally {
        proveBtn.disabled = false;
    }
}

/**
 * Verify current proof
 */
async function verifyProof() {
    if (!currentProof || !currentTraceBytes) {
        showStatus('No proof to verify', 'error');
        return;
    }
    
    verifyBtn.disabled = true;
    updateSteps(3);
    showStatus('Verifying proof...', 'loading');
    
    try {
        const valid = await verify_trace_proof(currentProof, currentTraceBytes);
        
        if (valid) {
            verificationStatusSpan.textContent = '✓ Valid';
            verificationStatusSpan.style.color = 'var(--success)';
            showStatus('Proof verified successfully!', 'success');
        } else {
            verificationStatusSpan.textContent = '✗ Invalid';
            verificationStatusSpan.style.color = 'var(--error)';
            showStatus('Proof verification failed', 'error');
        }
        
        setTimeout(hideStatus, 3000);
        
    } catch (error) {
        console.error('Verification failed:', error);
        verificationStatusSpan.textContent = `Error: ${error.message}`;
        showStatus(`Verification error: ${error.message}`, 'error');
    } finally {
        verifyBtn.disabled = false;
    }
}

/**
 * Copy proof to clipboard
 */
async function copyProof() {
    const hex = proofHexTextarea.value;
    if (!hex) return;
    
    try {
        await navigator.clipboard.writeText(hex);
        copyBtn.textContent = 'Copied!';
        setTimeout(() => {
            copyBtn.textContent = 'Copy to Clipboard';
        }, 2000);
    } catch (error) {
        console.error('Failed to copy:', error);
    }
}

// Event listeners
dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', (e) => {
    e.preventDefault();
    dropZone.classList.add('dragover');
});
dropZone.addEventListener('dragleave', () => {
    dropZone.classList.remove('dragover');
});
dropZone.addEventListener('drop', (e) => {
    e.preventDefault();
    dropZone.classList.remove('dragover');
    const file = e.dataTransfer.files[0];
    handleFile(file);
});
fileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    handleFile(file);
});
proveBtn.addEventListener('click', generateProof);
verifyBtn.addEventListener('click', verifyProof);
copyBtn.addEventListener('click', copyProof);

// Initialize on load
initWasm();
